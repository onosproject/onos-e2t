// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/onos/e2t/store/subscription/task.proto

// Package onos.e2t.store.subscription defines message types for E2T stores

package subscription

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TaskPhase is a subscription task phase
type TaskPhase int32

const (
	// OPEN is a subscription task open phase
	TaskPhase_OPEN TaskPhase = 0
	// CLOSE is a subscription task close phase
	TaskPhase_CLOSE TaskPhase = 1
)

var TaskPhase_name = map[int32]string{
	0: "OPEN",
	1: "CLOSE",
}

var TaskPhase_value = map[string]int32{
	"OPEN":  0,
	"CLOSE": 1,
}

func (x TaskPhase) String() string {
	return proto.EnumName(TaskPhase_name, int32(x))
}

func (TaskPhase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6408600f7d34afca, []int{0}
}

// TaskState is a subscription task state
type TaskState int32

const (
	// TASK_PENDING indicates the subscription task phase is pending
	TaskState_TASK_PENDING TaskState = 0
	// TASK_COMPLETE indicates the subscription task phase is complete
	TaskState_TASK_COMPLETE TaskState = 1
	// TASK_FAILED indicates the subscription task phase failed
	TaskState_TASK_FAILED TaskState = 2
)

var TaskState_name = map[int32]string{
	0: "TASK_PENDING",
	1: "TASK_COMPLETE",
	2: "TASK_FAILED",
}

var TaskState_value = map[string]int32{
	"TASK_PENDING":  0,
	"TASK_COMPLETE": 1,
	"TASK_FAILED":   2,
}

func (x TaskState) String() string {
	return proto.EnumName(TaskState_name, int32(x))
}

func (TaskState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6408600f7d34afca, []int{1}
}

// TaskFailureCause is a failure cause
type TaskFailureCause int32

const (
	TaskFailureCause_CAUSE_UNKNOWN                                                    TaskFailureCause = 0
	TaskFailureCause_CAUSE_MISC_CONTROL_PROCESSING_OVERLOAD                           TaskFailureCause = 1
	TaskFailureCause_CAUSE_MISC_HARDWARE_FAILURE                                      TaskFailureCause = 2
	TaskFailureCause_CAUSE_MISC_OM_INTERVENTION                                       TaskFailureCause = 3
	TaskFailureCause_CAUSE_MISC_UNSPECIFIED                                           TaskFailureCause = 4
	TaskFailureCause_CAUSE_PROTOCOL_TRANSFER_SYNTAX_ERROR                             TaskFailureCause = 5
	TaskFailureCause_CAUSE_PROTOCOL_ABSTRACT_SYNTAX_ERROR_REJECT                      TaskFailureCause = 6
	TaskFailureCause_CAUSE_PROTOCOL_ABSTRACT_SYNTAX_ERROR_IGNORE_AND_NOTIFY           TaskFailureCause = 7
	TaskFailureCause_CAUSE_PROTOCOL_MESSAGE_NOT_COMPATIBLE_WITH_RECEIVER_STATE        TaskFailureCause = 8
	TaskFailureCause_CAUSE_PROTOCOL_SEMANTIC_ERROR                                    TaskFailureCause = 9
	TaskFailureCause_CAUSE_PROTOCOL_ABSTRACT_SYNTAX_ERROR_FALSELY_CONSTRUCTED_MESSAGE TaskFailureCause = 10
	TaskFailureCause_CAUSE_PROTOCOL_UNSPECIFIED                                       TaskFailureCause = 11
	TaskFailureCause_CAUSE_RIC_RAN_FUNCTION_ID_INVALID                                TaskFailureCause = 12
	TaskFailureCause_CAUSE_RIC_ACTION_NOT_SUPPORTED                                   TaskFailureCause = 13
	TaskFailureCause_CAUSE_RIC_EXCESSIVE_ACTIONS                                      TaskFailureCause = 14
	TaskFailureCause_CAUSE_RIC_DUPLICATE_ACTION                                       TaskFailureCause = 15
	TaskFailureCause_CAUSE_RIC_DUPLICATE_EVENT                                        TaskFailureCause = 16
	TaskFailureCause_CAUSE_RIC_FUNCTION_RESOURCE_LIMIT                                TaskFailureCause = 17
	TaskFailureCause_CAUSE_RIC_REQUEST_ID_UNKNOWN                                     TaskFailureCause = 18
	TaskFailureCause_CAUSE_RIC_INCONSISTENT_ACTION_SUBSEQUENT_ACTION_SEQUENCE         TaskFailureCause = 19
	TaskFailureCause_CAUSE_RIC_CONTROL_MESSAGE_INVALID                                TaskFailureCause = 20
	TaskFailureCause_CAUSE_RIC_CALL_PROCESS_ID_INVALID                                TaskFailureCause = 21
	TaskFailureCause_CAUSE_RIC_UNSPECIFIED                                            TaskFailureCause = 22
	TaskFailureCause_CAUSE_RICSERVICE_FUNCTION_NOT_REQUIRED                           TaskFailureCause = 23
	TaskFailureCause_CAUSE_RICSERVICE_EXCESSIVE_FUNCTIONS                             TaskFailureCause = 24
	TaskFailureCause_CAUSE_RICSERVICE_RIC_RESOURCE_LIMIT                              TaskFailureCause = 25
	TaskFailureCause_CAUSE_TRANSPORT_UNSPECIFIED                                      TaskFailureCause = 26
	TaskFailureCause_CAUSE_TRANSPORT_TRANSPORT_RESOURCE_UNAVAILABLE                   TaskFailureCause = 27
)

var TaskFailureCause_name = map[int32]string{
	0:  "CAUSE_UNKNOWN",
	1:  "CAUSE_MISC_CONTROL_PROCESSING_OVERLOAD",
	2:  "CAUSE_MISC_HARDWARE_FAILURE",
	3:  "CAUSE_MISC_OM_INTERVENTION",
	4:  "CAUSE_MISC_UNSPECIFIED",
	5:  "CAUSE_PROTOCOL_TRANSFER_SYNTAX_ERROR",
	6:  "CAUSE_PROTOCOL_ABSTRACT_SYNTAX_ERROR_REJECT",
	7:  "CAUSE_PROTOCOL_ABSTRACT_SYNTAX_ERROR_IGNORE_AND_NOTIFY",
	8:  "CAUSE_PROTOCOL_MESSAGE_NOT_COMPATIBLE_WITH_RECEIVER_STATE",
	9:  "CAUSE_PROTOCOL_SEMANTIC_ERROR",
	10: "CAUSE_PROTOCOL_ABSTRACT_SYNTAX_ERROR_FALSELY_CONSTRUCTED_MESSAGE",
	11: "CAUSE_PROTOCOL_UNSPECIFIED",
	12: "CAUSE_RIC_RAN_FUNCTION_ID_INVALID",
	13: "CAUSE_RIC_ACTION_NOT_SUPPORTED",
	14: "CAUSE_RIC_EXCESSIVE_ACTIONS",
	15: "CAUSE_RIC_DUPLICATE_ACTION",
	16: "CAUSE_RIC_DUPLICATE_EVENT",
	17: "CAUSE_RIC_FUNCTION_RESOURCE_LIMIT",
	18: "CAUSE_RIC_REQUEST_ID_UNKNOWN",
	19: "CAUSE_RIC_INCONSISTENT_ACTION_SUBSEQUENT_ACTION_SEQUENCE",
	20: "CAUSE_RIC_CONTROL_MESSAGE_INVALID",
	21: "CAUSE_RIC_CALL_PROCESS_ID_INVALID",
	22: "CAUSE_RIC_UNSPECIFIED",
	23: "CAUSE_RICSERVICE_FUNCTION_NOT_REQUIRED",
	24: "CAUSE_RICSERVICE_EXCESSIVE_FUNCTIONS",
	25: "CAUSE_RICSERVICE_RIC_RESOURCE_LIMIT",
	26: "CAUSE_TRANSPORT_UNSPECIFIED",
	27: "CAUSE_TRANSPORT_TRANSPORT_RESOURCE_UNAVAILABLE",
}

var TaskFailureCause_value = map[string]int32{
	"CAUSE_UNKNOWN":                                                    0,
	"CAUSE_MISC_CONTROL_PROCESSING_OVERLOAD":                           1,
	"CAUSE_MISC_HARDWARE_FAILURE":                                      2,
	"CAUSE_MISC_OM_INTERVENTION":                                       3,
	"CAUSE_MISC_UNSPECIFIED":                                           4,
	"CAUSE_PROTOCOL_TRANSFER_SYNTAX_ERROR":                             5,
	"CAUSE_PROTOCOL_ABSTRACT_SYNTAX_ERROR_REJECT":                      6,
	"CAUSE_PROTOCOL_ABSTRACT_SYNTAX_ERROR_IGNORE_AND_NOTIFY":           7,
	"CAUSE_PROTOCOL_MESSAGE_NOT_COMPATIBLE_WITH_RECEIVER_STATE":        8,
	"CAUSE_PROTOCOL_SEMANTIC_ERROR":                                    9,
	"CAUSE_PROTOCOL_ABSTRACT_SYNTAX_ERROR_FALSELY_CONSTRUCTED_MESSAGE": 10,
	"CAUSE_PROTOCOL_UNSPECIFIED":                                       11,
	"CAUSE_RIC_RAN_FUNCTION_ID_INVALID":                                12,
	"CAUSE_RIC_ACTION_NOT_SUPPORTED":                                   13,
	"CAUSE_RIC_EXCESSIVE_ACTIONS":                                      14,
	"CAUSE_RIC_DUPLICATE_ACTION":                                       15,
	"CAUSE_RIC_DUPLICATE_EVENT":                                        16,
	"CAUSE_RIC_FUNCTION_RESOURCE_LIMIT":                                17,
	"CAUSE_RIC_REQUEST_ID_UNKNOWN":                                     18,
	"CAUSE_RIC_INCONSISTENT_ACTION_SUBSEQUENT_ACTION_SEQUENCE":         19,
	"CAUSE_RIC_CONTROL_MESSAGE_INVALID":                                20,
	"CAUSE_RIC_CALL_PROCESS_ID_INVALID":                                21,
	"CAUSE_RIC_UNSPECIFIED":                                            22,
	"CAUSE_RICSERVICE_FUNCTION_NOT_REQUIRED":                           23,
	"CAUSE_RICSERVICE_EXCESSIVE_FUNCTIONS":                             24,
	"CAUSE_RICSERVICE_RIC_RESOURCE_LIMIT":                              25,
	"CAUSE_TRANSPORT_UNSPECIFIED":                                      26,
	"CAUSE_TRANSPORT_TRANSPORT_RESOURCE_UNAVAILABLE":                   27,
}

func (x TaskFailureCause) String() string {
	return proto.EnumName(TaskFailureCause_name, int32(x))
}

func (TaskFailureCause) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6408600f7d34afca, []int{2}
}

// Type of change
type TaskEventType int32

const (
	TaskEventType_TASK_EVENT_UNKNOWN TaskEventType = 0
	TaskEventType_TASK_CREATED       TaskEventType = 1
	TaskEventType_TASK_UPDATED       TaskEventType = 2
	TaskEventType_TASK_DELETED       TaskEventType = 3
	TaskEventType_TASK_REPLAYED      TaskEventType = 4
)

var TaskEventType_name = map[int32]string{
	0: "TASK_EVENT_UNKNOWN",
	1: "TASK_CREATED",
	2: "TASK_UPDATED",
	3: "TASK_DELETED",
	4: "TASK_REPLAYED",
}

var TaskEventType_value = map[string]int32{
	"TASK_EVENT_UNKNOWN": 0,
	"TASK_CREATED":       1,
	"TASK_UPDATED":       2,
	"TASK_DELETED":       3,
	"TASK_REPLAYED":      4,
}

func (x TaskEventType) String() string {
	return proto.EnumName(TaskEventType_name, int32(x))
}

func (TaskEventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6408600f7d34afca, []int{3}
}

type TaskID struct {
	NodeID    NodeID    `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3,casttype=NodeID" json:"node_id,omitempty"`
	RequestID RequestID `protobuf:"bytes,2,opt,name=request_id,json=requestId,proto3,casttype=RequestID" json:"request_id,omitempty"`
	Hash      string    `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *TaskID) Reset()         { *m = TaskID{} }
func (m *TaskID) String() string { return proto.CompactTextString(m) }
func (*TaskID) ProtoMessage()    {}
func (*TaskID) Descriptor() ([]byte, []int) {
	return fileDescriptor_6408600f7d34afca, []int{0}
}
func (m *TaskID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskID.Merge(m, src)
}
func (m *TaskID) XXX_Size() int {
	return m.Size()
}
func (m *TaskID) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskID.DiscardUnknown(m)
}

var xxx_messageInfo_TaskID proto.InternalMessageInfo

func (m *TaskID) GetNodeID() NodeID {
	if m != nil {
		return m.NodeID
	}
	return ""
}

func (m *TaskID) GetRequestID() RequestID {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *TaskID) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

// Task is a subscription task
type Task struct {
	TaskMeta `protobuf:"bytes,1,opt,name=meta,proto3,embedded=meta" json:"meta"`
	Spec     TaskSpec   `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec"`
	Status   TaskStatus `protobuf:"bytes,3,opt,name=status,proto3" json:"status"`
}

func (m *Task) Reset()         { *m = Task{} }
func (m *Task) String() string { return proto.CompactTextString(m) }
func (*Task) ProtoMessage()    {}
func (*Task) Descriptor() ([]byte, []int) {
	return fileDescriptor_6408600f7d34afca, []int{1}
}
func (m *Task) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Task) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Task.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Task) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Task.Merge(m, src)
}
func (m *Task) XXX_Size() int {
	return m.Size()
}
func (m *Task) XXX_DiscardUnknown() {
	xxx_messageInfo_Task.DiscardUnknown(m)
}

var xxx_messageInfo_Task proto.InternalMessageInfo

func (m *Task) GetSpec() TaskSpec {
	if m != nil {
		return m.Spec
	}
	return TaskSpec{}
}

func (m *Task) GetStatus() TaskStatus {
	if m != nil {
		return m.Status
	}
	return TaskStatus{}
}

// TaskMeta is subscription task metadata
type TaskMeta struct {
	ID           TaskID       `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Revision     Revision     `protobuf:"varint,2,opt,name=revision,proto3,casttype=Revision" json:"revision,omitempty"`
	ServiceModel ServiceModel `protobuf:"bytes,3,opt,name=service_model,json=serviceModel,proto3" json:"service_model"`
}

func (m *TaskMeta) Reset()         { *m = TaskMeta{} }
func (m *TaskMeta) String() string { return proto.CompactTextString(m) }
func (*TaskMeta) ProtoMessage()    {}
func (*TaskMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_6408600f7d34afca, []int{2}
}
func (m *TaskMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskMeta.Merge(m, src)
}
func (m *TaskMeta) XXX_Size() int {
	return m.Size()
}
func (m *TaskMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskMeta.DiscardUnknown(m)
}

var xxx_messageInfo_TaskMeta proto.InternalMessageInfo

func (m *TaskMeta) GetID() TaskID {
	if m != nil {
		return m.ID
	}
	return TaskID{}
}

func (m *TaskMeta) GetRevision() Revision {
	if m != nil {
		return m.Revision
	}
	return 0
}

func (m *TaskMeta) GetServiceModel() ServiceModel {
	if m != nil {
		return m.ServiceModel
	}
	return ServiceModel{}
}

type TaskSpec struct {
	Subscription SubscriptionSpec `protobuf:"bytes,1,opt,name=subscription,proto3" json:"subscription"`
}

func (m *TaskSpec) Reset()         { *m = TaskSpec{} }
func (m *TaskSpec) String() string { return proto.CompactTextString(m) }
func (*TaskSpec) ProtoMessage()    {}
func (*TaskSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6408600f7d34afca, []int{3}
}
func (m *TaskSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskSpec.Merge(m, src)
}
func (m *TaskSpec) XXX_Size() int {
	return m.Size()
}
func (m *TaskSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TaskSpec proto.InternalMessageInfo

func (m *TaskSpec) GetSubscription() SubscriptionSpec {
	if m != nil {
		return m.Subscription
	}
	return SubscriptionSpec{}
}

// TaskStatus is the subscription task status
type TaskStatus struct {
	Phase          TaskPhase    `protobuf:"varint,1,opt,name=phase,proto3,enum=onos.e2t.store.subscription.TaskPhase" json:"phase,omitempty"`
	State          TaskState    `protobuf:"varint,2,opt,name=state,proto3,enum=onos.e2t.store.subscription.TaskState" json:"state,omitempty"`
	Failure        *TaskFailure `protobuf:"bytes,3,opt,name=failure,proto3" json:"failure,omitempty"`
	MastershipTerm uint64       `protobuf:"varint,4,opt,name=mastership_term,json=mastershipTerm,proto3" json:"mastership_term,omitempty"`
}

func (m *TaskStatus) Reset()         { *m = TaskStatus{} }
func (m *TaskStatus) String() string { return proto.CompactTextString(m) }
func (*TaskStatus) ProtoMessage()    {}
func (*TaskStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_6408600f7d34afca, []int{4}
}
func (m *TaskStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskStatus.Merge(m, src)
}
func (m *TaskStatus) XXX_Size() int {
	return m.Size()
}
func (m *TaskStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskStatus.DiscardUnknown(m)
}

var xxx_messageInfo_TaskStatus proto.InternalMessageInfo

func (m *TaskStatus) GetPhase() TaskPhase {
	if m != nil {
		return m.Phase
	}
	return TaskPhase_OPEN
}

func (m *TaskStatus) GetState() TaskState {
	if m != nil {
		return m.State
	}
	return TaskState_TASK_PENDING
}

func (m *TaskStatus) GetFailure() *TaskFailure {
	if m != nil {
		return m.Failure
	}
	return nil
}

func (m *TaskStatus) GetMastershipTerm() uint64 {
	if m != nil {
		return m.MastershipTerm
	}
	return 0
}

// TaskFailure is a subscription failure status
type TaskFailure struct {
	Cause   TaskFailureCause `protobuf:"varint,1,opt,name=cause,proto3,enum=onos.e2t.store.subscription.TaskFailureCause" json:"cause,omitempty"`
	Message string           `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *TaskFailure) Reset()         { *m = TaskFailure{} }
func (m *TaskFailure) String() string { return proto.CompactTextString(m) }
func (*TaskFailure) ProtoMessage()    {}
func (*TaskFailure) Descriptor() ([]byte, []int) {
	return fileDescriptor_6408600f7d34afca, []int{5}
}
func (m *TaskFailure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskFailure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskFailure.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskFailure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskFailure.Merge(m, src)
}
func (m *TaskFailure) XXX_Size() int {
	return m.Size()
}
func (m *TaskFailure) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskFailure.DiscardUnknown(m)
}

var xxx_messageInfo_TaskFailure proto.InternalMessageInfo

func (m *TaskFailure) GetCause() TaskFailureCause {
	if m != nil {
		return m.Cause
	}
	return TaskFailureCause_CAUSE_UNKNOWN
}

func (m *TaskFailure) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// TaskEvent is a subscription Task event
type TaskEvent struct {
	Type TaskEventType `protobuf:"varint,1,opt,name=type,proto3,enum=onos.e2t.store.subscription.TaskEventType" json:"type,omitempty"`
	Task Task          `protobuf:"bytes,2,opt,name=task,proto3" json:"task"`
}

func (m *TaskEvent) Reset()         { *m = TaskEvent{} }
func (m *TaskEvent) String() string { return proto.CompactTextString(m) }
func (*TaskEvent) ProtoMessage()    {}
func (*TaskEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6408600f7d34afca, []int{6}
}
func (m *TaskEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskEvent.Merge(m, src)
}
func (m *TaskEvent) XXX_Size() int {
	return m.Size()
}
func (m *TaskEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskEvent.DiscardUnknown(m)
}

var xxx_messageInfo_TaskEvent proto.InternalMessageInfo

func (m *TaskEvent) GetType() TaskEventType {
	if m != nil {
		return m.Type
	}
	return TaskEventType_TASK_EVENT_UNKNOWN
}

func (m *TaskEvent) GetTask() Task {
	if m != nil {
		return m.Task
	}
	return Task{}
}

func init() {
	proto.RegisterEnum("onos.e2t.store.subscription.TaskPhase", TaskPhase_name, TaskPhase_value)
	proto.RegisterEnum("onos.e2t.store.subscription.TaskState", TaskState_name, TaskState_value)
	proto.RegisterEnum("onos.e2t.store.subscription.TaskFailureCause", TaskFailureCause_name, TaskFailureCause_value)
	proto.RegisterEnum("onos.e2t.store.subscription.TaskEventType", TaskEventType_name, TaskEventType_value)
	proto.RegisterType((*TaskID)(nil), "onos.e2t.store.subscription.TaskID")
	proto.RegisterType((*Task)(nil), "onos.e2t.store.subscription.Task")
	proto.RegisterType((*TaskMeta)(nil), "onos.e2t.store.subscription.TaskMeta")
	proto.RegisterType((*TaskSpec)(nil), "onos.e2t.store.subscription.TaskSpec")
	proto.RegisterType((*TaskStatus)(nil), "onos.e2t.store.subscription.TaskStatus")
	proto.RegisterType((*TaskFailure)(nil), "onos.e2t.store.subscription.TaskFailure")
	proto.RegisterType((*TaskEvent)(nil), "onos.e2t.store.subscription.TaskEvent")
}

func init() {
	proto.RegisterFile("api/onos/e2t/store/subscription/task.proto", fileDescriptor_6408600f7d34afca)
}

var fileDescriptor_6408600f7d34afca = []byte{
	// 1216 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0x4f, 0x6f, 0x13, 0x47,
	0x14, 0xcf, 0x1a, 0x27, 0xb1, 0x5f, 0x12, 0x18, 0xa6, 0x40, 0x43, 0x28, 0x36, 0x98, 0x02, 0xa9,
	0x2b, 0x6c, 0xc9, 0x95, 0xaa, 0xd2, 0xd2, 0xd2, 0xf1, 0xee, 0x38, 0x4c, 0x59, 0xef, 0xba, 0x33,
	0x63, 0x87, 0x9c, 0x56, 0x26, 0x9e, 0x12, 0x0b, 0x12, 0xbb, 0xde, 0x0d, 0x12, 0x5f, 0xa0, 0xea,
	0xb1, 0x1f, 0x0b, 0xa9, 0x17, 0xa4, 0x5e, 0x7a, 0x8a, 0xaa, 0xf0, 0x19, 0x7a, 0x41, 0x3d, 0x54,
	0x33, 0xeb, 0xf5, 0xae, 0xd3, 0x2a, 0xc9, 0x6d, 0xe7, 0xcd, 0xef, 0xf7, 0xfe, 0xfc, 0xde, 0xbc,
	0xa7, 0x85, 0x6a, 0x7f, 0x3c, 0xac, 0x8f, 0x0e, 0x46, 0x61, 0x5d, 0x35, 0xa2, 0x7a, 0x18, 0x8d,
	0x26, 0xaa, 0x1e, 0x1e, 0x3e, 0x0f, 0x77, 0x27, 0xc3, 0x71, 0x34, 0x1c, 0x1d, 0xd4, 0xa3, 0x7e,
	0xf8, 0xb2, 0x36, 0x9e, 0x8c, 0xa2, 0x11, 0xbe, 0xa1, 0x71, 0x35, 0xd5, 0x88, 0x6a, 0x06, 0x57,
	0xcb, 0xe2, 0x36, 0xae, 0xbc, 0x18, 0xbd, 0x18, 0x19, 0x5c, 0x5d, 0x7f, 0xc5, 0x94, 0x8d, 0xda,
	0x69, 0xae, 0xb3, 0x87, 0x18, 0x5f, 0xf9, 0xc5, 0x82, 0x25, 0xd9, 0x0f, 0x5f, 0x32, 0x07, 0x3f,
	0x80, 0xe5, 0x83, 0xd1, 0x40, 0x05, 0xc3, 0xc1, 0xba, 0x75, 0xcb, 0xda, 0x2c, 0x36, 0xaf, 0x1c,
	0x1f, 0x95, 0x97, 0xbc, 0xd1, 0x40, 0x31, 0xe7, 0xc3, 0xec, 0x8b, 0x2f, 0x69, 0x10, 0x1b, 0xe0,
	0x87, 0x00, 0x13, 0xf5, 0xf3, 0xa1, 0x0a, 0x23, 0xcd, 0xc8, 0x19, 0xc6, 0xc6, 0xf1, 0x51, 0xb9,
	0xc8, 0x63, 0xab, 0x21, 0xa5, 0x07, 0x5e, 0x9c, 0xa2, 0xd9, 0x00, 0x63, 0xc8, 0xef, 0xf5, 0xc3,
	0xbd, 0xf5, 0x0b, 0x9a, 0xc4, 0xcd, 0x77, 0xe5, 0x0f, 0x0b, 0xf2, 0x3a, 0x11, 0x6c, 0x43, 0x7e,
	0x5f, 0x45, 0x7d, 0x93, 0xc3, 0x4a, 0xe3, 0x6e, 0xed, 0x14, 0x0d, 0x6a, 0x9a, 0xd0, 0x56, 0x51,
	0xbf, 0x59, 0x78, 0x7b, 0x54, 0x5e, 0x78, 0x77, 0x54, 0xb6, 0xb8, 0x21, 0xe3, 0xc7, 0x90, 0x0f,
	0xc7, 0x6a, 0xd7, 0xa4, 0x75, 0x1e, 0x27, 0x62, 0xac, 0x76, 0x9b, 0x79, 0xed, 0x84, 0x1b, 0x22,
	0xa6, 0xb0, 0x14, 0x46, 0xfd, 0xe8, 0x30, 0x34, 0x49, 0xae, 0x34, 0xee, 0x9f, 0xed, 0xc2, 0xc0,
	0xa7, 0x4e, 0xa6, 0xe4, 0xca, 0xef, 0x16, 0x14, 0x92, 0x24, 0xf1, 0x63, 0xc8, 0x4d, 0xb5, 0x5d,
	0x69, 0xdc, 0x39, 0xd3, 0x1f, 0x73, 0x9a, 0xa0, 0x7d, 0x1d, 0x1f, 0x95, 0x73, 0xcc, 0xe1, 0xb9,
	0xe1, 0x00, 0x6f, 0x42, 0x61, 0xa2, 0x5e, 0x0f, 0xc3, 0xe1, 0xe8, 0xc0, 0x54, 0x96, 0x6f, 0xae,
	0x7e, 0x38, 0x2a, 0x17, 0xf8, 0xd4, 0xc6, 0x67, 0xb7, 0x58, 0xc2, 0x5a, 0xa8, 0x26, 0xaf, 0x87,
	0xbb, 0x2a, 0xd8, 0x1f, 0x0d, 0xd4, 0xab, 0x69, 0x15, 0x9f, 0x9d, 0x1a, 0x55, 0xc4, 0x8c, 0xb6,
	0x26, 0x4c, 0xeb, 0x58, 0x0d, 0x33, 0xb6, 0xca, 0x6e, 0x5c, 0x8c, 0x16, 0x0b, 0x6f, 0xc3, 0x6a,
	0x96, 0x3c, 0x2d, 0xeb, 0xc1, 0xe9, 0x01, 0x32, 0x87, 0x8c, 0xe2, 0x73, 0x8e, 0x2a, 0x7f, 0x5b,
	0x00, 0xa9, 0x9e, 0xf8, 0x11, 0x2c, 0x8e, 0xf7, 0xfa, 0xa1, 0x32, 0x01, 0x2e, 0x36, 0xee, 0x9d,
	0xa9, 0x5b, 0x47, 0xa3, 0x79, 0x4c, 0xd2, 0x6c, 0xdd, 0x09, 0x65, 0xe4, 0x3a, 0x0f, 0x5b, 0x47,
	0x55, 0x3c, 0x26, 0xe1, 0x26, 0x2c, 0xff, 0xd4, 0x1f, 0xbe, 0x3a, 0x9c, 0xa8, 0xa9, 0x7e, 0x9b,
	0x67, 0xf2, 0x5b, 0x31, 0x9e, 0x27, 0x44, 0x7c, 0x1f, 0x2e, 0xed, 0xf7, 0xc3, 0x48, 0x4d, 0xc2,
	0xbd, 0xe1, 0x38, 0x88, 0xd4, 0x64, 0x7f, 0x3d, 0xaf, 0x5b, 0xc7, 0x2f, 0xa6, 0x66, 0xa9, 0x26,
	0xfb, 0x95, 0x57, 0xb0, 0x92, 0x71, 0x80, 0x6d, 0x58, 0xdc, 0xed, 0x1f, 0xce, 0xea, 0x7e, 0x70,
	0xde, 0xc8, 0xb6, 0x26, 0xf1, 0x98, 0x8b, 0xd7, 0x61, 0x79, 0x5f, 0x85, 0x61, 0xff, 0x45, 0x2c,
	0x40, 0x91, 0x27, 0xc7, 0xca, 0xaf, 0x16, 0x14, 0x35, 0x8b, 0xbe, 0x56, 0x07, 0x11, 0xfe, 0x0e,
	0xf2, 0xd1, 0x9b, 0x71, 0x12, 0xab, 0x7a, 0x66, 0x2c, 0xc3, 0x92, 0x6f, 0xc6, 0x8a, 0x1b, 0x1e,
	0xfe, 0x06, 0xf2, 0x7a, 0x6d, 0x4d, 0xc7, 0xed, 0xf6, 0x99, 0xfc, 0x64, 0xd4, 0x34, 0xa9, 0x7a,
	0x2b, 0xce, 0xc4, 0xf4, 0x0d, 0x17, 0x20, 0xef, 0x77, 0xa8, 0x87, 0x16, 0x70, 0x11, 0x16, 0x6d,
	0xd7, 0x17, 0x14, 0x59, 0x55, 0x12, 0x23, 0x4c, 0x6f, 0x30, 0x82, 0x55, 0x49, 0xc4, 0xd3, 0xa0,
	0x43, 0x3d, 0x87, 0x79, 0x5b, 0x68, 0x01, 0x5f, 0x86, 0x35, 0x63, 0xb1, 0xfd, 0x76, 0xc7, 0xa5,
	0x92, 0x22, 0x0b, 0x5f, 0x82, 0x15, 0x63, 0x6a, 0x11, 0xe6, 0x52, 0x07, 0xe5, 0xaa, 0xff, 0x14,
	0x00, 0x9d, 0x54, 0x49, 0x13, 0x6d, 0xd2, 0x15, 0x34, 0xe8, 0x7a, 0x4f, 0x3d, 0x7f, 0x5b, 0x47,
	0xad, 0xc2, 0xbd, 0xd8, 0xd4, 0x66, 0xc2, 0x0e, 0x6c, 0xdf, 0x93, 0xdc, 0x77, 0x83, 0x0e, 0xf7,
	0x6d, 0x2a, 0x04, 0xf3, 0xb6, 0x02, 0xbf, 0x47, 0xb9, 0xeb, 0x13, 0x07, 0x59, 0xb8, 0x0c, 0x37,
	0x32, 0xd8, 0x27, 0x84, 0x3b, 0xdb, 0x84, 0x53, 0x13, 0xb3, 0xcb, 0x29, 0xca, 0xe1, 0x12, 0x6c,
	0x64, 0x00, 0x7e, 0x3b, 0x60, 0x9e, 0xa4, 0xbc, 0x47, 0x3d, 0xc9, 0x7c, 0x0f, 0x5d, 0xc0, 0x1b,
	0x70, 0x2d, 0x73, 0xdf, 0xf5, 0x44, 0x87, 0xda, 0xac, 0xc5, 0xa8, 0x83, 0xf2, 0x78, 0x13, 0x3e,
	0x8d, 0xef, 0x3a, 0xdc, 0x97, 0xbe, 0xed, 0xbb, 0x81, 0xe4, 0xc4, 0x13, 0x2d, 0xca, 0x03, 0xb1,
	0xe3, 0x49, 0xf2, 0x2c, 0xa0, 0x9c, 0xfb, 0x1c, 0x2d, 0xe2, 0x3a, 0x7c, 0x7e, 0x02, 0x49, 0x9a,
	0x42, 0x72, 0x62, 0xcb, 0x39, 0x64, 0xc0, 0xe9, 0x0f, 0xd4, 0x96, 0x68, 0x09, 0x7f, 0x0d, 0x5f,
	0x9e, 0x8b, 0xc0, 0xb6, 0x3c, 0x9f, 0xd3, 0x80, 0x78, 0x4e, 0xe0, 0xf9, 0x92, 0xb5, 0x76, 0xd0,
	0x32, 0xfe, 0x16, 0x1e, 0x9e, 0xe0, 0xb6, 0xa9, 0x10, 0x64, 0x8b, 0x6a, 0x88, 0xe9, 0x00, 0x91,
	0xac, 0xe9, 0xd2, 0x60, 0x9b, 0xc9, 0x27, 0x01, 0xa7, 0x36, 0x65, 0x3d, 0x9d, 0xb2, 0x24, 0x92,
	0xa2, 0x02, 0xbe, 0x0d, 0x37, 0x4f, 0xd0, 0x05, 0x6d, 0x13, 0x4f, 0x32, 0x7b, 0x5a, 0x4e, 0x11,
	0x3b, 0xf0, 0xfd, 0xb9, 0xb2, 0x6b, 0x11, 0x57, 0x50, 0x77, 0x47, 0xf7, 0x48, 0x48, 0xde, 0xb5,
	0x25, 0x75, 0x92, 0x5c, 0x10, 0xa4, 0xd2, 0xcf, 0xbc, 0x64, 0xe5, 0x5d, 0xc1, 0x77, 0xe1, 0x76,
	0x7c, 0xcf, 0x99, 0x1d, 0x70, 0xe2, 0x05, 0xad, 0xae, 0x67, 0xeb, 0xb6, 0x04, 0xcc, 0x09, 0x98,
	0xd7, 0x23, 0x2e, 0x73, 0xd0, 0x2a, 0xae, 0x40, 0x29, 0x85, 0x91, 0x18, 0xa0, 0x0b, 0x15, 0xdd,
	0x4e, 0xc7, 0xe7, 0x92, 0x3a, 0x68, 0x2d, 0x7d, 0x06, 0x1a, 0x43, 0x9f, 0x99, 0x87, 0xd2, 0xa3,
	0x53, 0xb4, 0x40, 0x17, 0xd3, 0x5c, 0x34, 0xc0, 0xe9, 0x76, 0x5c, 0x66, 0x13, 0x99, 0x00, 0xd0,
	0x25, 0x7c, 0x13, 0xae, 0xff, 0xdf, 0x3d, 0xd5, 0x0f, 0x05, 0xa1, 0xf9, 0x54, 0x67, 0x69, 0x72,
	0x2a, 0xfc, 0x2e, 0xb7, 0x69, 0xe0, 0xb2, 0x36, 0x93, 0xe8, 0x32, 0xbe, 0x05, 0x9f, 0x64, 0x2a,
	0xa2, 0x3f, 0x76, 0xa9, 0x90, 0xba, 0x98, 0xe4, 0x6d, 0x63, 0xfc, 0x08, 0xbe, 0x4a, 0x11, 0xcc,
	0xd3, 0xc2, 0x31, 0x21, 0xa9, 0x27, 0x93, 0xca, 0x44, 0xb7, 0x29, 0x34, 0x31, 0x63, 0x31, 0x47,
	0x9b, 0xa2, 0x8f, 0xe6, 0xd3, 0x48, 0x06, 0x23, 0x69, 0x7e, 0xa2, 0xd8, 0x95, 0x13, 0x30, 0xe2,
	0xce, 0x86, 0x27, 0x2b, 0xec, 0x55, 0x7c, 0x1d, 0xae, 0xa6, 0xb0, 0x6c, 0x6b, 0xae, 0xa5, 0x23,
	0xc8, 0x99, 0x2d, 0x28, 0xef, 0x31, 0x9b, 0xa6, 0x65, 0x6b, 0xf1, 0x75, 0x71, 0x8c, 0x53, 0x07,
	0x7d, 0x9c, 0x4e, 0x49, 0x06, 0x9b, 0xb6, 0x20, 0x61, 0x09, 0xb4, 0x8e, 0xef, 0xc3, 0x9d, 0xff,
	0x20, 0x63, 0xa5, 0xe6, 0x74, 0xbc, 0x9e, 0xb6, 0xd3, 0xcc, 0x9b, 0xee, 0xf2, 0x5c, 0x7e, 0x1b,
	0xb8, 0x01, 0xb5, 0x93, 0x80, 0xf4, 0x6b, 0xe6, 0xae, 0xeb, 0x91, 0x1e, 0x61, 0x2e, 0x69, 0xba,
	0x14, 0xdd, 0xa8, 0x8e, 0x61, 0x6d, 0x6e, 0x6f, 0xe2, 0x6b, 0x80, 0xcd, 0x82, 0x32, 0x4d, 0xce,
	0xec, 0x9f, 0x64, 0xbb, 0xd9, 0x9c, 0x12, 0xfd, 0xbc, 0xac, 0x99, 0xa5, 0xdb, 0x71, 0x8c, 0x25,
	0x37, 0xb3, 0x38, 0x54, 0x6f, 0x3b, 0x07, 0x5d, 0x98, 0x6d, 0x40, 0x4e, 0x3b, 0x2e, 0xd9, 0xd1,
	0xfb, 0xa3, 0xb9, 0xfe, 0xf6, 0xb8, 0x64, 0xbd, 0x3b, 0x2e, 0x59, 0x7f, 0x1d, 0x97, 0xac, 0xdf,
	0xde, 0x97, 0x16, 0xde, 0xbd, 0x2f, 0x2d, 0xfc, 0xf9, 0xbe, 0xb4, 0xf0, 0x7c, 0xc9, 0xfc, 0xf9,
	0x7d, 0xf1, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x78, 0x7b, 0xa9, 0x89, 0x8a, 0x0a, 0x00, 0x00,
}

func (m *TaskID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintTask(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RequestID) > 0 {
		i -= len(m.RequestID)
		copy(dAtA[i:], m.RequestID)
		i = encodeVarintTask(dAtA, i, uint64(len(m.RequestID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeID) > 0 {
		i -= len(m.NodeID)
		copy(dAtA[i:], m.NodeID)
		i = encodeVarintTask(dAtA, i, uint64(len(m.NodeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Task) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Task) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Task) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTask(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTask(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.TaskMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTask(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TaskMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ServiceModel.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTask(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Revision != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.Revision))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTask(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TaskSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Subscription.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTask(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TaskStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MastershipTerm != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.MastershipTerm))
		i--
		dAtA[i] = 0x20
	}
	if m.Failure != nil {
		{
			size, err := m.Failure.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTask(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if m.Phase != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.Phase))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TaskFailure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskFailure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskFailure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTask(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cause != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.Cause))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TaskEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Task.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTask(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Type != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTask(dAtA []byte, offset int, v uint64) int {
	offset -= sovTask(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TaskID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovTask(uint64(l))
	}
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovTask(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTask(uint64(l))
	}
	return n
}

func (m *Task) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TaskMeta.Size()
	n += 1 + l + sovTask(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTask(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovTask(uint64(l))
	return n
}

func (m *TaskMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ID.Size()
	n += 1 + l + sovTask(uint64(l))
	if m.Revision != 0 {
		n += 1 + sovTask(uint64(m.Revision))
	}
	l = m.ServiceModel.Size()
	n += 1 + l + sovTask(uint64(l))
	return n
}

func (m *TaskSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Subscription.Size()
	n += 1 + l + sovTask(uint64(l))
	return n
}

func (m *TaskStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Phase != 0 {
		n += 1 + sovTask(uint64(m.Phase))
	}
	if m.State != 0 {
		n += 1 + sovTask(uint64(m.State))
	}
	if m.Failure != nil {
		l = m.Failure.Size()
		n += 1 + l + sovTask(uint64(l))
	}
	if m.MastershipTerm != 0 {
		n += 1 + sovTask(uint64(m.MastershipTerm))
	}
	return n
}

func (m *TaskFailure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cause != 0 {
		n += 1 + sovTask(uint64(m.Cause))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTask(uint64(l))
	}
	return n
}

func (m *TaskEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTask(uint64(m.Type))
	}
	l = m.Task.Size()
	n += 1 + l + sovTask(uint64(l))
	return n
}

func sovTask(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTask(x uint64) (n int) {
	return sovTask(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TaskID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTask
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = NodeID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = RequestID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTask(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTask
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTask
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Task) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTask
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Task: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Task: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TaskMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTask(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTask
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTask
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTask
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Revision |= Revision(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceModel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ServiceModel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTask(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTask
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTask
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTask
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscription", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Subscription.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTask(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTask
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTask
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTask
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= TaskPhase(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= TaskState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Failure == nil {
				m.Failure = &TaskFailure{}
			}
			if err := m.Failure.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MastershipTerm", wireType)
			}
			m.MastershipTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MastershipTerm |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTask(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTask
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTask
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskFailure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTask
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskFailure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskFailure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cause", wireType)
			}
			m.Cause = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cause |= TaskFailureCause(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTask(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTask
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTask
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTask
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TaskEventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Task.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTask(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTask
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTask
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTask(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTask
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTask
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTask
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTask
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTask
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTask
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTask        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTask          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTask = fmt.Errorf("proto: unexpected end of group")
)
